{"version":3,"sources":["ellah/vedn.cljs"],"mappings":"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","names":["ellah.vedn/test-str","ellah.vedn/whitespace-characters","ellah.vedn/opener->type","ellah.vedn/type->opener","clojure.set/map-invert","ellah.vedn/type->closer","ellah.vedn/closer-tokens","cljs.core/vec","cljs.core/set","cljs.core/vals","ellah.vedn/special-tokens","cljs.core.concat","cljs.core/keys","ellah.vedn/break-token","token","cljs.core/reverse","cljs.core.filter","cljs.core/seq","size","cljs.core/count","index","subtokens","subtoken-start","in-string?","cljs.core.conj","cljs.core.subs","special-token","cljs.core/some","cljs.core._EQ_","quote?","cljs.core.nth","cljs.core.not_EQ_","special-token-size","ellah.vedn/tokenize-clj","clj-str","str-index","past-tokens","token-start","in-str?","current-character","whitespace?","or__4126__auto__","ellah.vedn/strip-single-line-comments","stripped-chars","comment?","cljs.core.apply","cljs.core/str","character","in-comment?","ellah.vedn/literal-form","ellah.vedn/get-child","form","path","cljs.core/empty?","G__432491","G__432492","cljs.core/first","cljs.core/rest","ellah.vedn/add-child","child","p1__432493#","cljs.core.update","p1__432494#","cljs.core.update_in","G__432495","G__432496","G__432497","ellah.vedn/vector-insert","v","value","bounded-index","x__4214__auto__","y__4215__auto__","x__4217__auto__","y__4218__auto__","cljs.core.subvec","cljs.core/List","ellah.vedn/vector-remove","ellah.vedn/insert-child","p1__432498#","p1__432499#","G__432500","G__432501","G__432502","ellah.vedn/replace-child","p1__432503#","G__432504","G__432505","G__432506","ellah.vedn/remove-child","p1__432507#","p1__432508#","G__432509","G__432510","ellah.vedn/tokens->vedn","tokens","token-index","opener-type","ellah.util/in?","cljs.core/pop","ellah.vedn/clj->vedn","ellah.vedn/vedn->clj","map__432511","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get","type","children","cljs.core.map","first?","cljs.core/not","cljs.core.repeat"],"sourcesContent":["(ns ellah.vedn\n  (:require [ellah.util :as u]\n            [clojure.set :as sets]\n            [clojure.edn :as edn]))\n\n(def test-str\n  \"(nth\n   (iterate (fn [f]\n                   \n                   (conj f\n                         (+ (last f)\n                          (last (butlast f)))))\n                 [0 1])\n   (+ 1 2))\")\n\n(def whitespace-characters #{\" \" \"\\t\" \"\\n\"})\n\n(def opener->type {\"(\" :list\n                   \"[\" :vector\n                   \"{\" :map\n                   \"#{\" :set\n                   \"#(\" :lit-fn})\n\n(def type->opener (sets/map-invert opener->type))\n\n(def type->closer {:list \")\"\n                   :vector \"]\"\n                   :map \"}\"\n                   :set \"}\"\n                   :lit-fn \")\"})\n\n(def closer-tokens (vec (set (vals type->closer))))\n\n(def special-tokens (vec (concat (keys opener->type)\n                                 closer-tokens\n                                 [\"#_\"\n                                  \"#'\"\n                                  \"##Inf\"\n                                  \"##-Inf\"\n                                  \"##NaN\"\n                                  \"@\"\n                                  \"'\"\n                                  \"`\"\n                                  \"~@\"\n                                  \"~\"])))\n\n(defn break-token [token]\n  (reverse\n   (filter seq\n           (let [size (count token)]\n             (loop [index 0\n                    subtokens '()\n                    subtoken-start 0\n                    in-string? false]\n               (if (>= index size)\n                 (conj subtokens (subs token subtoken-start))\n                 (let [special-token (some (fn [special-token]\n                                             (when (= special-token\n                                                      (subs token index (+ index (count special-token))))\n                                               special-token))\n                                           special-tokens)\n                       quote? (and (= (nth token index) \\\")\n                                   (not= (subs token (dec index) index) \\\\))]\n                   (if in-string?\n                     (if quote?\n                       (recur (inc index)\n                              (conj subtokens\n                                    (str \\\"\n                                         (subs token\n                                               subtoken-start\n                                               index)\n                                         \\\"))\n                              (inc index)\n                              false)\n                       (recur (inc index)\n                              subtokens\n                              subtoken-start\n                              true))\n                     (if special-token\n                       (let [special-token-size (count special-token)]\n                         (recur (+ index special-token-size)\n                                (conj subtokens\n                                      (subs token\n                                            subtoken-start\n                                            index)\n                                      special-token)\n                                (+ index special-token-size)\n                                false))\n                       (if quote?\n                         (recur (inc index)\n                                (conj subtokens\n                                      (subs token\n                                            subtoken-start\n                                            index))\n                                (inc index)\n                                true)\n                         (recur (inc index)\n                                subtokens\n                                subtoken-start\n                                false)))))))))))\n\n(defn tokenize-clj [clj-str]\n  (let [size (count clj-str)]\n    (loop [str-index 0\n           past-tokens '()\n           token-start nil\n           in-str? false]\n      (if (>= str-index size)\n        (vec\n         (if token-start\n           (concat past-tokens\n                   (break-token (subs clj-str token-start)))\n           past-tokens))\n        (let [current-character (nth clj-str str-index)\n              whitespace? (whitespace-characters current-character)\n              quote? (= current-character \\\")]\n          (if in-str?\n            (if quote?\n              (if (= (nth clj-str (dec str-index)) \\\\)\n                (recur (inc str-index)\n                       past-tokens\n                       token-start\n                       true)\n                (recur (inc str-index)\n                       (if token-start\n                         (concat past-tokens\n                                 (break-token (subs clj-str token-start (inc str-index))))\n                         past-tokens)\n                       nil\n                       false))\n              (recur (inc str-index)\n                     past-tokens\n                     token-start\n                     true))\n            (if whitespace?\n              (recur (inc str-index)\n                     (if token-start\n                       (concat past-tokens\n                               (break-token (subs clj-str token-start str-index)))\n                       past-tokens)\n                     nil\n                     false)\n              (recur (inc str-index)\n                     past-tokens\n                     (or token-start str-index)\n                     quote?))))))))\n\n(defn strip-single-line-comments [clj-str]\n  (loop [index 0\n         stripped-chars []\n         comment? false\n         in-string? false]\n    (if (>= index (count clj-str))\n      (apply str stripped-chars)\n      (let [character (nth clj-str index)\n            quote? (and (not comment?)\n                        (= character \\\")\n                        (not (= (nth clj-str (dec index)) \\\\)))]\n        (if in-string?\n          (recur (inc index)\n                 (conj stripped-chars character)\n                 false\n                 (not quote?))\n          (let [in-comment? (or comment? (= character \\;))]\n            (recur (inc index)\n                   (if in-comment?\n                     stripped-chars\n                     (conj stripped-chars character))\n                   (and in-comment?\n                        (not= character \\newline))\n                   quote?)))))))\n\n(defn literal-form [token]\n  {:type :literal\n   :value token})\n\n(defn get-child [form path]\n  (if (empty? path)\n    form\n    (get-child (nth (:children form)\n                    (first path))\n               (rest path))))\n\n(defn add-child [form path child]\n  (if (empty? path)\n    (update form\n            :children #(conj % child))\n    (update-in form\n               [:children (first path)]\n               #(add-child %\n                           (rest path)\n                           child))))\n\n(defn vector-insert [v index value]\n  (if (empty? v)\n    [value]\n    (let [bounded-index (max 0 (min (dec count) index))]\n      (vec (concat (subvec v 0 bounded-index)\n                   (list value)\n                   (subvec v bounded-index))))))\n\n(defn vector-remove [v index]\n  (vec (concat (subvec v 0 index)\n               (subvec v (inc index)))))\n\n(defn insert-child [form path child]\n  (if (= (count path) 1)\n    (update form\n            :children #(vector-insert % (inc (first path)) child))\n    (update-in form\n               [:children (first path)]\n               #(insert-child %\n                              (rest path)\n                              child))))\n\n(defn replace-child [form path child]\n  (if (empty? path)\n    child\n    (update-in form\n               [:children (first path)]\n               #(replace-child %\n                               (rest path)\n                               child))))\n\n(defn remove-child [form path]\n  (if (= (count path) 1)\n    (update form\n            :children\n            #(vector-remove % (first path)))\n    (update-in form\n               [:children (first path)]\n               #(remove-child % (rest path)))))\n\n(defn tokens->vedn [tokens]\n  (loop [token-index 0\n         form {:type :vector :children []}\n         path []]\n    (if (>= token-index (count tokens))\n      form\n      (let [token (nth tokens token-index)\n            opener-type (opener->type token)]\n        (if opener-type\n          (recur (inc token-index)\n                 (add-child form path\n                            {:type opener-type\n                             :children []})\n                 (conj path (count (:children (get-child form path)))))\n          (if (u/in? closer-tokens token)\n            (recur (inc token-index)\n                   form\n                   (pop path))\n            (recur (inc token-index)\n                   (add-child form path (literal-form token))\n                   path)))))))\n\n(defn clj->vedn [clj-str]\n  (-> clj-str\n      strip-single-line-comments\n      tokenize-clj\n      tokens->vedn))\n\n(defn vedn->clj [form]\n  (let [{:keys [type value children]} form]\n    (if (= type :literal)\n      value\n      (str (type->opener type)\n           (apply str\n                  (map (fn [child first?]\n                         (str (when (not first?) \" \")\n                              (vedn->clj child)))\n                       children\n                       (conj (repeat false) true)))\n           (type->closer type)))))"]}