shadow$provide.module$node_modules$promise_polyfill$lib$index=function(global,require,module,exports){function noop(){}function bind(fn,thisArg){return function(){fn.apply(thisArg,arguments)}}function Promise(fn){if(!(this instanceof Promise))throw new TypeError("Promises must be constructed via new");if("function"!==typeof fn)throw new TypeError("not a function");this._state=0;this._handled=!1;this._value=void 0;this._deferreds=[];doResolve(fn,this)}function handle(self,deferred){for(;3===self._state;)self=
self._value;0===self._state?self._deferreds.push(deferred):(self._handled=!0,Promise._immediateFn(function(){var cb=1===self._state?deferred.onFulfilled:deferred.onRejected;if(null===cb)(1===self._state?resolve:reject)(deferred.promise,self._value);else{try{var ret=cb(self._value)}catch(e){reject(deferred.promise,e);return}resolve(deferred.promise,ret)}}))}function resolve(self,newValue){try{if(newValue===self)throw new TypeError("A promise cannot be resolved with itself.");if(newValue&&("object"===
typeof newValue||"function"===typeof newValue)){var then=newValue.then;if(newValue instanceof Promise){self._state=3;self._value=newValue;finale(self);return}if("function"===typeof then){doResolve(bind(then,newValue),self);return}}self._state=1;self._value=newValue;finale(self)}catch(e){reject(self,e)}}function reject(self,newValue){self._state=2;self._value=newValue;finale(self)}function finale(self){2===self._state&&0===self._deferreds.length&&Promise._immediateFn(function(){self._handled||Promise._unhandledRejectionFn(self._value)});
for(var i=0,len=self._deferreds.length;i<len;i++)handle(self,self._deferreds[i]);self._deferreds=null}function Handler(onFulfilled,onRejected,promise){this.onFulfilled="function"===typeof onFulfilled?onFulfilled:null;this.onRejected="function"===typeof onRejected?onRejected:null;this.promise=promise}function doResolve(fn,self){var done=!1;try{fn(function(value){done||(done=!0,resolve(self,value))},function(reason){done||(done=!0,reject(self,reason))})}catch(ex){done||(done=!0,reject(self,ex))}}var setTimeoutFunc=
setTimeout;Promise.prototype["catch"]=function(onRejected){return this.then(null,onRejected)};Promise.prototype.then=function(onFulfilled,onRejected){var prom=new this.constructor(noop);handle(this,new Handler(onFulfilled,onRejected,prom));return prom};Promise.prototype["finally"]=function(callback){var constructor=this.constructor;return this.then(function(value){return constructor.resolve(callback()).then(function(){return value})},function(reason){return constructor.resolve(callback()).then(function(){return constructor.reject(reason)})})};
Promise.all=function(arr){return new Promise(function(resolve,reject){function res(i,val$jscomp$0){try{if(val$jscomp$0&&("object"===typeof val$jscomp$0||"function"===typeof val$jscomp$0)){var then=val$jscomp$0.then;if("function"===typeof then){then.call(val$jscomp$0,function(val){res(i,val)},reject);return}}args[i]=val$jscomp$0;0===--remaining&&resolve(args)}catch(ex){reject(ex)}}if(!arr||"undefined"===typeof arr.length)return reject(new TypeError("Promise.all accepts an array"));var args=Array.prototype.slice.call(arr);
if(0===args.length)return resolve([]);for(var remaining=args.length,i$jscomp$0=0;i$jscomp$0<args.length;i$jscomp$0++)res(i$jscomp$0,args[i$jscomp$0])})};Promise.allSettled=function(arr){return new this(function(resolve,reject){function res(i,val){if(val&&("object"===typeof val||"function"===typeof val)){var then=val.then;if("function"===typeof then){then.call(val,function(val){res(i,val)},function(e){args[i]={status:"rejected",reason:e};0===--remaining&&resolve(args)});return}}args[i]={status:"fulfilled",
value:val};0===--remaining&&resolve(args)}if(!arr||"undefined"===typeof arr.length)return reject(new TypeError(typeof arr+" "+arr+" is not iterable(cannot read property Symbol(Symbol.iterator))"));var args=Array.prototype.slice.call(arr);if(0===args.length)return resolve([]);var remaining=args.length;for(reject=0;reject<args.length;reject++)res(reject,args[reject])})};Promise.resolve=function(value){return value&&"object"===typeof value&&value.constructor===Promise?value:new Promise(function(resolve){resolve(value)})};
Promise.reject=function(value){return new Promise(function(resolve,reject){reject(value)})};Promise.race=function(arr){return new Promise(function(resolve,reject){if(!arr||"undefined"===typeof arr.length)return reject(new TypeError("Promise.race accepts an array"));for(var i=0,len=arr.length;i<len;i++)Promise.resolve(arr[i]).then(resolve,reject)})};Promise._immediateFn="function"===typeof setImmediate&&function(fn){setImmediate(fn)}||function(fn){setTimeoutFunc(fn,0)};Promise._unhandledRejectionFn=
function(err){"undefined"!==typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",err)};module.exports=Promise}
//# sourceMappingURL=module$node_modules$promise_polyfill$lib$index.js.map
