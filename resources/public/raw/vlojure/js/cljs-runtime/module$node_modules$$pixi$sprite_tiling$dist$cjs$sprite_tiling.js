shadow$provide.module$node_modules$$pixi$sprite_tiling$dist$cjs$sprite_tiling=function(global,require,module,exports){function __extends(d,b){function __(){this.constructor=d}extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}Object.defineProperty(exports,"__esModule",{value:!0});var core=require("module$node_modules$$pixi$core$dist$cjs$core"),math=require("module$node_modules$$pixi$math$dist$cjs$math");global=require("module$node_modules$$pixi$sprite$dist$cjs$sprite");
var constants=require("module$node_modules$$pixi$constants$dist$cjs$constants"),utils=require("module$node_modules$$pixi$utils$dist$cjs$utils"),extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)},tempPoint=new math.Point;require=function(_super){function TilingSprite(texture,width,height){void 0===width&&
(width=100);void 0===height&&(height=100);var _this=_super.call(this,texture)||this;_this.tileTransform=new math.Transform;_this._width=width;_this._height=height;_this.uvMatrix=_this.texture.uvMatrix||new core.TextureMatrix(texture);_this.pluginName="tilingSprite";_this.uvRespectAnchor=!1;return _this}__extends(TilingSprite,_super);Object.defineProperty(TilingSprite.prototype,"clampMargin",{get:function(){return this.uvMatrix.clampMargin},set:function(value){this.uvMatrix.clampMargin=value;this.uvMatrix.update(!0)},
enumerable:!1,configurable:!0});Object.defineProperty(TilingSprite.prototype,"tileScale",{get:function(){return this.tileTransform.scale},set:function(value){this.tileTransform.scale.copyFrom(value)},enumerable:!1,configurable:!0});Object.defineProperty(TilingSprite.prototype,"tilePosition",{get:function(){return this.tileTransform.position},set:function(value){this.tileTransform.position.copyFrom(value)},enumerable:!1,configurable:!0});TilingSprite.prototype._onTextureUpdate=function(){this.uvMatrix&&
(this.uvMatrix.texture=this._texture);this._cachedTint=16777215};TilingSprite.prototype._render=function(renderer){var texture=this._texture;texture&&texture.valid&&(this.tileTransform.updateLocalTransform(),this.uvMatrix.update(),renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]),renderer.plugins[this.pluginName].render(this))};TilingSprite.prototype._calculateBounds=function(){this._bounds.addFrame(this.transform,this._width*-this._anchor._x,this._height*-this._anchor._y,this._width*
(1-this._anchor._x),this._height*(1-this._anchor._y))};TilingSprite.prototype.getLocalBounds=function(rect){return 0===this.children.length?(this._bounds.minX=this._width*-this._anchor._x,this._bounds.minY=this._height*-this._anchor._y,this._bounds.maxX=this._width*(1-this._anchor._x),this._bounds.maxY=this._height*(1-this._anchor._y),rect||(this._localBoundsRect||(this._localBoundsRect=new math.Rectangle),rect=this._localBoundsRect),this._bounds.getRectangle(rect)):_super.prototype.getLocalBounds.call(this,
rect)};TilingSprite.prototype.containsPoint=function(point){this.worldTransform.applyInverse(point,tempPoint);var width=this._width;point=this._height;var x1=-width*this.anchor._x;return tempPoint.x>=x1&&tempPoint.x<x1+width&&(width=-point*this.anchor._y,tempPoint.y>=width&&tempPoint.y<width+point)?!0:!1};TilingSprite.prototype.destroy=function(options){_super.prototype.destroy.call(this,options);this.uvMatrix=this.tileTransform=null};TilingSprite.from=function(source,options){source=source instanceof
core.Texture?source:core.Texture.from(source,options);return new TilingSprite(source,options.width,options.height)};Object.defineProperty(TilingSprite.prototype,"width",{get:function(){return this._width},set:function(value){this._width=value},enumerable:!1,configurable:!0});Object.defineProperty(TilingSprite.prototype,"height",{get:function(){return this._height},set:function(value){this._height=value},enumerable:!1,configurable:!0});return TilingSprite}(global.Sprite);var tempMat=new math.Matrix;
global=function(_super){function TilingSpriteRenderer(renderer){renderer=_super.call(this,renderer)||this;var uniforms={globals:renderer.renderer.globalUniforms};renderer.shader=core.Shader.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position \x3d vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord \x3d (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",
"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord \x3d vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord \x3d (uMapCoord * vec3(coord, 1.0)).xy;\n    coord \x3d clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample \x3d texture2D(uSampler, coord);\n    gl_FragColor \x3d texSample * uColor;\n}\n",uniforms);renderer.simpleShader=
core.Shader.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position \x3d vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord \x3d (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample \x3d texture2D(uSampler, vTextureCoord);\n    gl_FragColor \x3d sample * uColor;\n}\n",
uniforms);renderer.quad=new core.QuadUv;renderer.state=core.State.for2d();return renderer}__extends(TilingSpriteRenderer,_super);TilingSpriteRenderer.prototype.render=function(ts){var renderer=this.renderer,quad=this.quad,vertices=quad.vertices;vertices[0]=vertices[6]=ts._width*-ts.anchor.x;vertices[1]=vertices[3]=ts._height*-ts.anchor.y;vertices[2]=vertices[4]=ts._width*(1-ts.anchor.x);vertices[5]=vertices[7]=ts._height*(1-ts.anchor.y);var anchorX=ts.uvRespectAnchor?ts.anchor.x:0,anchorY=ts.uvRespectAnchor?
ts.anchor.y:0;vertices=quad.uvs;vertices[0]=vertices[6]=-anchorX;vertices[1]=vertices[3]=-anchorY;vertices[2]=vertices[4]=1-anchorX;vertices[5]=vertices[7]=1-anchorY;quad.invalidate();vertices=ts._texture;anchorX=vertices.baseTexture;anchorY=ts.tileTransform.localTransform;var uv=ts.uvMatrix,isSimple=anchorX.isPowerOfTwo&&vertices.frame.width===anchorX.width&&vertices.frame.height===anchorX.height;isSimple&&(anchorX._glTextures[renderer.CONTEXT_UID]?isSimple=anchorX.wrapMode!==constants.WRAP_MODES.CLAMP:
anchorX.wrapMode===constants.WRAP_MODES.CLAMP&&(anchorX.wrapMode=constants.WRAP_MODES.REPEAT));var shader=isSimple?this.simpleShader:this.shader,w=vertices.width,h=vertices.height,W=ts._width,H=ts._height;tempMat.set(anchorY.a*w/W,anchorY.b*w/H,anchorY.c*h/W,anchorY.d*h/H,anchorY.tx/W,anchorY.ty/H);tempMat.invert();isSimple?tempMat.prepend(uv.mapCoord):(shader.uniforms.uMapCoord=uv.mapCoord.toArray(!0),shader.uniforms.uClampFrame=uv.uClampFrame,shader.uniforms.uClampOffset=uv.uClampOffset);shader.uniforms.uTransform=
tempMat.toArray(!0);shader.uniforms.uColor=utils.premultiplyTintToRgba(ts.tint,ts.worldAlpha,shader.uniforms.uColor,anchorX.alphaMode);shader.uniforms.translationMatrix=ts.transform.worldTransform.toArray(!0);shader.uniforms.uSampler=vertices;renderer.shader.bind(shader);renderer.geometry.bind(quad);this.state.blendMode=utils.correctBlendMode(ts.blendMode,anchorX.alphaMode);renderer.state.set(this.state);renderer.geometry.draw(this.renderer.gl.TRIANGLES,6,0)};return TilingSpriteRenderer}(core.ObjectRenderer);
exports.TilingSprite=require;exports.TilingSpriteRenderer=global}
//# sourceMappingURL=module$node_modules$$pixi$sprite_tiling$dist$cjs$sprite_tiling.js.map
